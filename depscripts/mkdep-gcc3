#! /usr/bin/perl -w
#
# Run the gcc or g++ compiler and at the same time generate dependency (.d) file
# for each source file.

use strict;
use English;

use File::Basename;

# Find a file in a search path
# Usage: my $fullname = findInPath(<filename>, <dir1>, <dir2>, ...)
sub findInPath
{
    my $name = shift;

    return $name if ($name =~ m(^/));	# Absolute path name given

    foreach my $dir (@ARG)
    {
	my $fullname = $dir . $name;
	$fullname =~ s(//)(/)g;
	return $fullname if ( -f $fullname);
    }

    return undef;
}

my $makefile = $ENV{MAKEFILE};
my $make = $ENV{MAKE};
my $depdir = $ENV{DEPDIR};
my $dlistlistname = $ENV{DEPLIST};

if (! defined($dlistlistname))
{
    # Not run from dmake: use normal compiler
    exit system("@ARGV") / 256;
}

my $gcc=$ARGV[0];
shift @ARGV;

# Parse gcc arguments:
my @cppopt;
my $dolink=1;
my @srclist;
my @linkobjs;
my @libpath = qw(/lib /usr/lib /usr/local/lib);
my $targetname="";
foreach my $arg (@ARGV)
{
    # -o option requires two steps
    if ($targetname eq "?")
    {
	# -o option seen on last loop
	$targetname = $arg;
    }
    elsif ($arg eq "-o")
    {
	$targetname="?";	# Get object directory on next loop
    }

    # Keep a list of -I, -D and -U pre-processor options
    elsif ($arg =~ /^-[IDU].*/ || $arg =~ /^-include.*/ )
    {
	# Add pre-processor directive to cpp options list
	push @cppopt, $arg;
    }

    # Keep a list of source files (.c, .cc, .cpp, etc.)
    elsif ($arg =~ m/^.*\.(c|cc|cpp|cxx)/io )
    {
	push @srclist, $arg;
    }

    # Keep a list of linker objects (.a, .o, and .so files)
    elsif ($arg =~ /-L(.*)/)
    {
	push @libpath, $1;
    }
    elsif ($arg =~ /-l(.*)/)
    {
	# Search for .a file or, if not found, search for .so file
	my $libname = $1;
	my $libfile = findInPath("lib$libname.a", @libpath);
	$libfile = findInPath("lib$libname.so", @libpath)
	    unless (defined($libfile));

	push @linkobjs, $libfile if (defined($libfile));
    }
    elsif ($arg =~ m/^.*\.(o|a|so)/o )
    {
	push @linkobjs, $arg;
    }

    # Check if linking is turned off
    elsif ($arg eq '-c')
    {
	$dolink=0;
    }
}

my $depfile;
if ($targetname ne "")
{
    # If there is an explicit target, use it to name the dependency file.
    $depfile = "$depdir/" . basename("$targetname.d");
}
elsif ($dolink)
{
    # Implicit target of a.out if linking is turned on and no other target.
    $targetname = "a.out";
    $depfile = "$depdir/a.out.d";
}
elsif (@srclist)
{
    # No signle target use the first source file name to compute $depfile
    my $objname = $srclist[0];
    $objname =~ s/\.[^\.]*$/.o/ ;
    $depfile = "$depdir/" . basename("$objname.d");
}
else
{
    # No targets that we can find
    $depfile = "/dev/null";
}

# Eliminate leading "./"
$depfile =~ s:^\./::o ; 

# Generate dependency file for each source file
for my $arg (@srclist)
{
    my $objname = $targetname;
    if ($objname eq "")
    {
	$objname = $arg;
	$objname =~ s/\.[^\.]*$/.o/ ;
    }

    # Put object file directory at front of rule generated by gcc -M
    open DEPFILE, ">> $depfile.tmp" or
	die "Cannot open $depfile.tmp for write/append\n";
    print DEPFILE dirname($objname) . "/";
    close DEPFILE;

    # Now generate dependencies:
    my $gccret = system("$gcc -M @cppopt $arg >> $depfile.tmp") / 256;
}

# Create dependency list for linker objects
if ($dolink)
{
    # Put object file directory at front of rule generated by gcc -M
    open DEPFILE, ">> $depfile.tmp" or
	die "Cannot open $depfile.tmp for write/append\n";
    print DEPFILE $targetname, ": @linkobjs\n";
    close DEPFILE;
}

# Now run the normal compiler
my $gccret = system("$gcc @ARGV") / 256;

if ($gccret)
{
    # Discard dependencies on compilation failure
    unlink("$depfile.tmp");

    exit $gccret;
}

# Commit changes to dependency file and register in list of dependency files.
rename("$depfile.tmp", $depfile);
open DLISTLIST, ">> $dlistlistname" or die "Cannot append to $dlistlistname\n";
print DLISTLIST basename($depfile), "\n";
close DLISTLIST;

exit 0;
